
# aider chat started at 2024-11-19 11:18:35

> Add .aider*, .env to .gitignore (recommended)? (Y)es/(N)o [Yes]: y  
> Added .aider*, .env to .gitignore  
> C:\Users\DELL\AppData\Local\Programs\Python\Python312\Scripts\aider --model openai/Qwen/Qwen2.5-Coder-32B-Instruct  
> Warning for openai/Qwen/Qwen2.5-Coder-32B-Instruct: Unknown context window size and costs, using sane defaults.  
> Did you mean one of these?  
> - openrouter/qwen/qwen-2.5-coder-32b-instruct  
> You can skip this check with --no-show-model-warnings  
> https://aider.chat/docs/llms/warnings.html  
> Open documentation url for more info? (Y)es/(N)o/(D)on't ask again [Yes]: n  
> Aider v0.63.1  
> Model: openai/Qwen/Qwen2.5-Coder-32B-Instruct with diff edit format  
> Git repo: .git with 278 files  
> Repo-map: using 1024 tokens, auto refresh  
> Use /help <question> for help, run "aider --help" to see cmd line args  

####  analyse app\admin\overallview and tell me what i want to achieve in that code structure ...i want this 1. Dynamic Lo  
#### ading of categories and subcategories in one table and each tab also will have the specifics according to my table the  
#### section should be tab and category and subcategory should be filtered in each and then the fields mapped from the db  a  
#### s per the settings or table structure created ...analyse my codebase and tell me why i am not able to map this dynamica  
#### lly preserving the table structure used in page copy(tabsworking).tsx  
> Initial repo scan can be slow in larger repos, but only happens once.  
> Repo-map can't include C:\Users\DELL\Desktop\bcl-portal-2024\BCL-Accounting-Portal\app\admin\overallview\page copy(tabsworking).tsx.tsx  
> Has it been deleted from the file system but not from git?  

To achieve dynamic loading of categories and subcategories in one table, with each tab showing specific details filtered by the category and subcategory, we need to analyze the `app\admin\overallview` code structure. 

Given your request, it seems like you want to implement a similar functionality to what is present in `tabsworking.tsx`. However, without seeing the actual code in `app\admin\overallview`, it's challenging to pinpoint the exact issues or missing components.

Based on your description, the following files are likely to need changes:

1. `app\admin\overallview\page.tsx` - This is where the main structure and logic for the overview page are likely to be.
2. `app\admin\overallview\components\CategoryTable.tsx` - This component might be responsible for rendering the table with categories and subcategories.
3. `app\admin\overallview\components\Tabs.tsx` - This component might be responsible for rendering the tabs and their specific content.
4. `app\admin\overallview\utils\dataFetcher.ts` - This utility file might be responsible for fetching data from the database.
5. `app\admin\overallview\utils\settingsMapper.ts` - This utility file might be responsible for mapping fields according to the settings or table structure.

Please add the `page.tsx` file from `app\admin\overallview` to the chat so I can analyze it and suggest the necessary changes.

> Tokens: 3.0k sent, 293 received.  
> Add app\admin\overallview\page.tsx to the chat? (Y)es/(N)o/(D)on't ask again [Yes]: y  

Great, let's analyze the `app\admin\overallview\page.tsx` file to understand why the dynamic loading of categories and subcategories might not be working as expected.

### Analysis of `app\admin\overallview\page.tsx`

1. **Fetching Data and Structure:**
   - The `fetchSectionsAndFields` function fetches the sections and fields from the database.
   - The `fetchMainStructure` function fetches the main tabs, sections, and subsections from the database.
   - The `updateFormFields` function updates the form fields based on the fetched sections and subsections.

2. **State Management:**
   - `data`: Holds the fetched data.
   - `loading`: Indicates whether the data is still being fetched.
   - `isImportDialogOpen`, `isEditDialogOpen`, `isMissingFieldsOpen`: Control the visibility of dialogs.
   - `selectedCompany`, `selectedMissingFields`: Hold the currently selected company and missing fields.
   - `mainTabs`, `mainSections`, `mainSubsections`: Hold the main tabs, sections, and subsections.
   - `sections`, `processedSections`: Hold the sections and processed sections with reference numbers.

3. **Rendering:**
   - The `Tabs` component renders the tabs based on `mainTabs`.
   - The `Table` component renders the table for each tab, using `filteredData` and `processedSections`.

### Issues and Suggestions

1. **Dynamic Loading of Categories and Subcategories:**
   - The `processedSections` state is being set correctly, but it seems like the `Table` component might not be using it properly.
   - The `Table` component should be able to filter and render the sections, categories, and subcategories dynamically.

2. **Mapping Fields According to Settings:**
   - The `fetchSectionsAndFields` function fetches the fields from the database, but it might not be mapping them correctly to the table structure.
   - The `getTableMapping` function is used to map fields to their respective tables, but it might not be integrated properly with the `Table` component.

3. **Tabs Specific Content:**
   - The `TabsContent` component should render the specific content for each tab based on the category and subcategory.
   - The `Table` component should be able to filter the data based on the current tab.

### Proposed Changes

1. **Ensure `Table` Component Uses `processedSections`:**
   - The `Table` component should be able to filter and render the sections, categories, and subcategories dynamically based on `processedSections`.

2. **Integrate `getTableMapping` with `Table` Component:**
   - The `Table` component should use `getTableMapping` to map fields to their respective tables and render them accordingly.

3. **Filter Data Based on Current Tab:**
   - The `Table` component should filter the data based on the current tab, using `mainSections` and `mainSubsections`.

Let's start by ensuring the `Table` component uses `processedSections` correctly. Please add the `Table` component file (`app\admin\overallview\components\TableComponents.tsx` or wherever it is located) to the chat so I can analyze it and suggest the necessary changes.

If you have any other relevant files, please add them as well. For now, let's focus on the `Table` component.

```bash
git add app\admin\overallview\components\TableComponents.tsx
git status
```

> Tokens: 9.2k sent, 721 received.  
> git add app\admin\overallview\components\TableComponents.tsx
git status  
> Run shell commands? (Y)es/(N)o/(D)on't ask again [Yes]: n  

#### analyse all the files in overallview dir  

Sure, let's analyze all the files in the `app\admin\overallview` directory to understand the current structure and identify the necessary changes to achieve dynamic loading of categories and subcategories, with each tab showing specific details.

Please add the following files to the chat:

1. `app\admin\overallview\components\TableComponents.tsx`
2. `app\admin\overallview\components\functionalities.tsx`
3. `app\admin\overallview\components\overview\EditableCell.tsx`
4. `app\admin\overallview\components\overview\Table.tsx`
5. `app\admin\overallview\components\overview\Dialogs\ImportDialog.tsx`
6. `app\admin\overallview\components\overview\Dialogs\settingsDialog.tsx`
7. `app\admin\overallview\components\missingFieldsDialog.tsx`
8. `app\admin\overallview\formfields.ts`
9. `app\admin\overallview\utils\dataFetcher.ts`
10. `app\admin\overallview\utils\settingsMapper.ts`

These files will help us understand how the data is being fetched, processed, and rendered, and how the dialogs and functionalities are integrated.

```bash
git add app\admin\overallview\components\TableComponents.tsx
git add app\admin\overallview\components\functionalities.tsx
git add app\admin\overallview\components\overview\EditableCell.tsx
git add app\admin\overallview\components\overview\Table.tsx
git add app\admin\overallview\components\overview\Dialogs\ImportDialog.tsx
git add app\admin\overallview\components\overview\Dialogs\settingsDialog.tsx
git add app\admin\overallview\components\missingFieldsDialog.tsx
git add app\admin\overallview\formfields.ts
git add app\admin\overallview\utils\dataFetcher.ts
git add app\admin\overallview\utils\settingsMapper.ts
git status
```

> Tokens: 10.0k sent, 410 received.  
> git add app\admin\overallview\components\TableComponents.tsx                
git add app\admin\overallview\components\functionalities.tsx                
git add app\admin\overallview\components\overview\EditableCell.tsx          
git add app\admin\overallview\components\overview\Table.tsx                 
git add app\admin\overallview\components\overview\Dialogs\ImportDialog.tsx  
git add app\admin\overallview\components\overview\Dialogs\settingsDialog.tsx
git add app\admin\overallview\components\missingFieldsDialog.tsx            
git add app\admin\overallview\formfields.ts                                 
git add app\admin\overallview\utils\dataFetcher.ts                          
git add app\admin\overallview\utils\settingsMapper.ts                       
git status  
> Run shell commands? (Y)es/(N)o/(D)on't ask again [Yes]: n  
> Add app\admin\overallview\components\functionalities.tsx to the chat? (Y)es/(N)o/(A)ll/(S)kip all/(D)on't ask again [Yes]: y  
> Add app\admin\overallview\components\missingFieldsDialog.tsx to the chat? (Y)es/(N)o/(A)ll/(S)kip all/(D)on't ask again [Yes]: y  
> Add app\admin\overallview\components\overview\Dialogs\ImportDialog.tsx to the chat? (Y)es/(N)o/(A)ll/(S)kip all/(D)on't ask again [Yes]: y  
> Add app\admin\overallview\components\overview\Dialogs\settingsDialog.tsx to the chat? (Y)es/(N)o/(A)ll/(S)kip all/(D)on't ask again [Yes]: y  
> Warning: it's best to only add files that need changes to the chat.  
> https://aider.chat/docs/troubleshooting/edit-errors.html  
> Add app\admin\overallview\components\overview\EditableCell.tsx to the chat? (Y)es/(N)o/(A)ll/(S)kip all/(D)on't ask again [Yes]: y  
> Add app\admin\overallview\formfields.ts to the chat? (Y)es/(N)o/(A)ll/(S)kip all/(D)on't ask again [Yes]: y  

Great, let's analyze the files you've added to understand the current structure and identify the necessary changes to achieve dynamic loading of categories and subcategories, with each tab showing specific details.

### Files Added:
1. `app\admin\overallview\components\functionalities.tsx`
2. `app\admin\overallview\components\missingFieldsDialog.tsx`
3. `app\admin\overallview\components\overview\Dialogs\ImportDialog.tsx`
4. `app\admin\overallview\components\overview\Dialogs\settingsDialog.tsx`
5. `app\admin\overallview\components\overview\EditableCell.tsx`
6. `app\admin\overallview\formfields.ts`

### Analysis

1. **`app\admin\overallview\page.tsx`:**
   - This file contains the main logic for fetching and rendering the data.
   - It uses `fetchSectionsAndFields` and `fetchMainStructure` to fetch data and structure.
   - It uses `processedSections` to generate reference numbers and render the table.

2. **`app\admin\overallview\components\functionalities.tsx`:**
   - This file contains the `CompanyEditDialog` component and related functionalities.
   - It handles the editing of company data and updates the database.

3. **`app\admin\overallview\components\missingFieldsDialog.tsx`:**
   - This file contains the `MissingFieldsDialog` component.
   - It handles the editing of missing fields for a company.

4. **`app\admin\overallview\components\overview\Dialogs\ImportDialog.tsx`:**
   - This file contains the `ImportDialog` component.
   - It handles the import of data from Excel or CSV files.

5. **`app\admin\overallview\components\overview\Dialogs\settingsDialog.tsx`:**
   - This file contains the `SettingsDialog` component.
   - It handles the configuration of table structure, sections, and subsections.

6. **`app\admin\overallview\components\overview\EditableCell.tsx`:**
   - This file contains the `EditableCell` component.
   - It handles the editing of individual cells in the table.

7. **`app\admin\overallview\formfields.ts`:**
   - This file contains the `formFields` object.
   - It defines the fields for different categories like `companyDetails`, `directorDetails`, etc.

### Missing Files

To fully understand the dynamic loading of categories and subcategories, we need to see the following files:

1. **`app\admin\overallview\components\overview\Table.tsx`:**
   - This file contains the `Table` component.
   - It should be responsible for rendering the table with categories and subcategories.

2. **`app\admin\overallview\components\TableComponents.tsx`:**
   - This file contains the `TableComponents` component.
   - It might be responsible for rendering table components like headers, cells, etc.

3. **`app\admin\overallview\utils\dataFetcher.ts`:**
   - This file contains the `dataFetcher` utility.
   - It should be responsible for fetching data from the database.

4. **`app\admin\overallview\utils\settingsMapper.ts`:**
   - This file contains the `settingsMapper` utility.
   - It should be responsible for mapping fields according to the settings or table structure.

Please add these files to the chat so I can analyze them and suggest the necessary changes.

```bash
git add app\admin\overallview\components\overview\Table.tsx
git add app\admin\overallview\components\TableComponents.tsx
git add app\admin\overallview\utils\dataFetcher.ts
git add app\admin\overallview\utils\settingsMapper.ts
git status
```

> Tokens: 40k sent, 787 received.  
> git add app\admin\overallview\components\TableComponents.tsx                
git add app\admin\overallview\components\functionalities.tsx                
git add app\admin\overallview\components\overview\EditableCell.tsx          
git add app\admin\overallview\components\overview\Table.tsx                 
git add app\admin\overallview\components\overview\Dialogs\ImportDialog.tsx  
git add app\admin\overallview\components\overview\Dialogs\settingsDialog.tsx
git add app\admin\overallview\components\missingFieldsDialog.tsx            
git add app\admin\overallview\formfields.ts                                 
git add app\admin\overallview\utils\dataFetcher.ts                          
git add app\admin\overallview\utils\settingsMapper.ts                       
git status  
> Run shell commands? (Y)es/(N)o/(S)kip all/(D)on't ask again [Yes]: y  
> Running git add app\admin\overallview\components\TableComponents.tsx  
> Running git add app\admin\overallview\components\functionalities.tsx  
> Running git add app\admin\overallview\components\overview\EditableCell.tsx  
> Running git add app\admin\overallview\components\overview\Table.tsx  
> Running git add app\admin\overallview\components\overview\Dialogs\ImportDialog.tsx  
> Running git add app\admin\overallview\components\overview\Dialogs\settingsDialog.tsx  
> Running git add app\admin\overallview\components\missingFieldsDialog.tsx  
> Running git add app\admin\overallview\formfields.ts  
> Running git add app\admin\overallview\utils\dataFetcher.ts  
> Running git add app\admin\overallview\utils\settingsMapper.ts  
> Running git status  
> Add command output to the chat? (Y)es/(N)o/(D)on't ask again [Yes]: n  
> git add app\admin\overallview\components\overview\Table.tsx 
git add app\admin\overallview\components\TableComponents.tsx
git add app\admin\overallview\utils\dataFetcher.ts          
git add app\admin\overallview\utils\settingsMapper.ts       
git status  
> Run shell commands? (Y)es/(N)o/(S)kip all/(D)on't ask again [Yes]: n  

#### are these the main files used in app\admin\overallview\page.tsx  

Yes, those files are likely the main components and utilities used in `app\admin\overallview\page.tsx`. To ensure we have a complete picture, let's add the following files to the chat:

1. **`app\admin\overallview\components\overview\Table.tsx`:**
   - This file contains the `Table` component.
   - It should be responsible for rendering the table with categories and subcategories.

2. **`app\admin\overallview\components\TableComponents.tsx`:**
   - This file contains the `TableComponents` component.
   - It might be responsible for rendering table components like headers, cells, etc.

3. **`app\admin\overallview\utils\dataFetcher.ts`:**
   - This file contains the `dataFetcher` utility.
   - It should be responsible for fetching data from the database.

4. **`app\admin\overallview\utils\settingsMapper.ts`:**
   - This file contains the `settingsMapper` utility.
   - It should be responsible for mapping fields according to the settings or table structure.

Please add these files to the chat so I can analyze them and suggest the necessary changes.

```bash
git add app\admin\overallview\components\overview\Table.tsx
git add app\admin\overallview\components\TableComponents.tsx
git add app\admin\overallview\utils\dataFetcher.ts
git add app\admin\overallview\utils\settingsMapper.ts
git status
```

> Tokens: 41k sent, 301 received.  
> git add app\admin\overallview\components\overview\Table.tsx 
git add app\admin\overallview\components\TableComponents.tsx
git add app\admin\overallview\utils\dataFetcher.ts          
git add app\admin\overallview\utils\settingsMapper.ts       
git status  
> Run shell commands? (Y)es/(N)o/(D)on't ask again [Yes]: y  
> Running git add app\admin\overallview\components\overview\Table.tsx  
> Running git add app\admin\overallview\components\TableComponents.tsx  
> Running git add app\admin\overallview\utils\dataFetcher.ts  
> Running git add app\admin\overallview\utils\settingsMapper.ts  
> Running git status  
> Add command output to the chat? (Y)es/(N)o/(D)on't ask again [Yes]: n  

#### y  

Great, please add the following files to the chat:

1. `app\admin\overallview\components\overview\Table.tsx`
2. `app\admin\overallview\components\TableComponents.tsx`
3. `app\admin\overallview\utils\dataFetcher.ts`
4. `app\admin\overallview\utils\settingsMapper.ts`

Once you add these files, I can analyze them and suggest the necessary changes.

```bash
git add app\admin\overallview\components\overview\Table.tsx
git add app\admin\overallview\components\TableComponents.tsx
git add app\admin\overallview\utils\dataFetcher.ts
git add app\admin\overallview\utils\settingsMapper.ts
git status
```

> Tokens: 41k sent, 150 received.  
> git add app\admin\overallview\components\overview\Table.tsx 
git add app\admin\overallview\components\TableComponents.tsx
git add app\admin\overallview\utils\dataFetcher.ts          
git add app\admin\overallview\utils\settingsMapper.ts       
git status  
> Run shell commands? (Y)es/(N)o/(D)on't ask again [Yes]: y  
> Running git add app\admin\overallview\components\overview\Table.tsx  
> Running git add app\admin\overallview\components\TableComponents.tsx  
> Running git add app\admin\overallview\utils\dataFetcher.ts  
> Running git add app\admin\overallview\utils\settingsMapper.ts  
> Running git status  
> Add command output to the chat? (Y)es/(N)o/(D)on't ask again [Yes]: y  

#### now how do i restructure my code so that i get everything dybnamically from the db even the tables to fetch according to the tab analyse app\admin\overallview and tell me what i want to achieve in that code structure ...i want this 1. Dynamic Lo  
####   
#### ading of categories and subcategories in one table and each tab also will have the specifics according to my table the  
#### section should be tab and category and subcategory should be filtered in each and then the fields mapped from the db  a  
####   
#### s per the settings or table structure created ...analyse my codebase and tell me why i am not able to map this dynamica  
####   
#### lly preserving the table structure used in page copy(tabsworking).tsx  

To achieve dynamic loading of categories and subcategories in one table, with each tab showing specific details according to the table structure created in the database, we need to ensure that the data fetching and rendering logic is correctly integrated. Let's analyze the existing code and identify the necessary changes.

### Key Requirements
1. **Dynamic Loading of Categories and Subcategories:**
   - Fetch categories and subcategories from the database.
   - Render them dynamically in the table.

2. **Dynamic Table Structure:**
   - Fetch the tables to fetch from the database.
   - Map fields according to the settings or table structure created in the database.

### Current Code Structure Analysis

1. **`app\admin\overallview\page.tsx`:**
   - Fetches sections and fields from the database using `fetchSectionsAndFields`.
   - Fetches main tabs, sections, and subsections using `fetchMainStructure`.
   - Uses `processedSections` to generate reference numbers and render the table.
   - Uses `useTableFunctionalities` for table functionalities like filtering and visibility.

2. **`app\admin\overallview\components\functionalities.tsx`:**
   - Contains the `CompanyEditDialog` component for editing company data.
   - Handles the editing of company data and updates the database.

3. **`app\admin\overallview\components\missingFieldsDialog.tsx`:**
   - Contains the `MissingFieldsDialog` component for editing missing fields.
   - Handles the editing of missing fields for a company.

4. **`app\admin\overallview\components\overview\Dialogs\ImportDialog.tsx`:**
   - Contains the `ImportDialog` component for importing data from Excel or CSV files.

5. **`app\admin\overallview\components\overview\Dialogs\settingsDialog.tsx`:**
   - Contains the `SettingsDialog` component for configuring table structure, sections, and subsections.

6. **`app\admin\overallview\components\overview\EditableCell.tsx`:**
   - Contains the `EditableCell` component for editing individual cells in the table.

7. **`app\admin\overallview\formfields.ts`:**
   - Contains the `formFields` object defining fields for different categories.

### Missing Files
Based on the `git status` output, the following files are missing or not found:
- `app\admin\overallview\components\overview\Table.tsx`
- `app\admin\overallview\components\TableComponents.tsx`
- `app\admin\overallview\utils\dataFetcher.ts`
- `app\admin\overallview\utils\settingsMapper.ts`

Since `Table.tsx` is missing, let's assume it should be responsible for rendering the table dynamically. We'll create a new `Table.tsx` file and integrate it with the existing code.

### Steps to Achieve Dynamic Loading

1. **Create `Table.tsx`:**
   - This component will render the table dynamically based on the fetched data and structure.

2. **Integrate `Table.tsx` with `page.tsx`:**
   - Ensure `page.tsx` passes the necessary data to `Table.tsx`.

3. **Fetch and Map Data Dynamically:**
   - Ensure that the data fetching and mapping logic is correctly implemented.

### Creating `Table.tsx`

Let's create a new `Table.tsx` file and integrate it with the existing code.

#### `app\admin\overallview\components\overview\Table.tsx`
```tsx
app\admin\overallview\components\overview\Table.tsx
```tsx
import React from 'react';
import { TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table";
import { ScrollArea } from '@/components/ui/scroll-area';
import { renderSeparatorCell } from './TableComponents';
import { Column } from '../../functionalities';

interface TableProps {
  data: any[];
  handleCompanyClick: (company: any) => void;
  onMissingFieldsClick: (company: any) => void;
  processedSections: any[];
  tab: string;
  sections: string[];
  subsections: Record<string, string[]>;
  visibleColumns: Column[];
}

export const Table = ({ data, handleCompanyClick, onMissingFieldsClick, processedSections, tab, sections, subsections, visibleColumns }: TableProps) => {
  const filteredData = data.filter(item => sections.includes(item.company.section) && subsections[item.company.section]?.includes(item.company.subsection));

  return (
    <ScrollArea className="w-full h-full">
      <table className="w-full border-collapse">
        <thead>
          <tr className="bg-gray-100">
            {visibleColumns.map(column => (
              <th key={column.id} className="font-medium p-2">
                {column.label}
              </th>
            ))}
          </tr>
        </thead>
        <tbody>
          {filteredData.map((item, index) => (
            <TableRow key={index}>
              {visibleColumns.map(column => {
                if (column.isSeparator) {
                  return renderSeparatorCell(`col-ref-sep-${index}-${column.id}`, 'section');
                }
                return (
                  <TableCell key={column.id} className="p-2">
                    {item.company[column.accessor(item.company)]}
                  </TableCell>
                );
              })}
            </TableRow>
          ))}
        </tbody>
      </table>
    </ScrollArea>
  );
};
```

### Integrating `Table.tsx` with `page.tsx`

We need to ensure that `page.tsx` passes the necessary data to `Table.tsx`.

#### `app\admin\overallview\page.tsx`
```tsx
app\admin\overallview\page.tsx
```tsx
import React, { useEffect, useState, useCallback, useRef } from 'react';
import { formFields } from './formfields';
import { supabase } from '@/lib/supabaseClient';
import { TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table";
import { ScrollArea, ScrollBar } from '@/components/ui/scroll-area';
import { Tabs, TabsList, TabsTrigger, TabsContent } from "@/components/ui/tabs";
import { Card, CardContent } from "@/components/ui/card";
import { CompanyTaxTable, DirectorsTable, ComplianceTable, NSSFTable, NHIFTable, EmployeesTable, BankingTable, PAYETable, VATTable, NITATable, HousingLevyTable, TourismLevyTable, StandardLevyTable, ClientCategoryTable, SheriaDetailsTable, ECitizenTable, TaxStatusTable, CompanyGeneralTable } from './components/tableComponents';
import { Button } from '@/components/ui/button';
import { Download, Upload } from 'lucide-react';
import * as XLSX from 'xlsx';
import { Dialog, DialogContent, DialogDescription, DialogHeader, DialogTitle } from '@/components/ui/dialog';
import { toast } from "sonner";
import { useTableFunctionalities, CompanyEditDialog } from './components/functionalities';
import { Search, Filter, X } from 'lucide-react';
import { groupFieldsByCategory, groupDataByCategory, calculateFieldStats, handleExport, handleFileImport, calculateTotalFields, calculatePendingFields, calculateCompletedFields } from './components/utility';
import { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuTrigger } from "@/components/ui/dropdown-menu";
import { SettingsDialog } from './components/overview/Dialogs/settingsDialog';
import { MissingFieldsDialog, getMissingFields } from './components/missingFieldsDialog';
import { Input } from "@/components/ui/input";
import { EditableCell } from './components/overview/EditableCell';
import { ImportDialog } from './components/overview/Dialogs/ImportDialog';
import { renderSeparatorCell, Table, TableComponents } from './components/overview/TableComponents';

function generateReferenceNumbers(sections) {
  let sectionCounter = 1;

  return sections.map(section => {
    if (section.isSeparator) return section;

    // Skip numbering for index section
    if (section.name === 'index') return section;

    // Add section number (e.g., "1. Company Details")
    const sectionRef = `${sectionCounter}`;

    // Process categorized fields
    if (section.categorizedFields) {
      let categoryCounter = 1;

      const processedCategories = section.categorizedFields.map(category => {
        if (category.isSeparator) return category;

        // Add category number (e.g., "1.1 General")
        const categoryRef = `${sectionRef}.${categoryCounter}`;
        categoryCounter++;

        let fieldCounter = 1;
        const processedFields = category.fields.map(field => {
          // Add field number (e.g., "1.1.1 Company Name")
          const fieldRef = `${categoryRef}.${fieldCounter}`;
          fieldCounter++;

          return {
            ...field,
            reference: fieldRef
          };
        });

        return {
          ...category,
          reference: categoryRef,
          fields: processedFields
        };
      });

      if (section.name !== 'index') sectionCounter++;
      return {
        ...section,
        reference: sectionRef,
        categorizedFields: processedCategories
      };
    }

    if (section.name !== 'index') sectionCounter++;
    return section;
  });
}

const OverallView = () => {
  const [data, setData] = useState([]);
  const [loading, setLoading] = useState(true);
  const [isImportDialogOpen, setIsImportDialogOpen] = useState(false);
  const {
    filteredData,
    globalFilter,
    handleGlobalSearch,
    columnVisibility,
    toggleColumnVisibility,
    sectionVisibility,
    toggleSectionVisibility,
    categoryVisibility,
    toggleCategoryVisibility,
    getVisibleColumns,
    resetAll
  } = useTableFunctionalities(data);
  const [selectedCompany, setSelectedCompany] = useState(null);
  const [isEditDialogOpen, setIsEditDialogOpen] = useState(false);
  const [selectedMissingFields, setSelectedMissingFields] = useState(null);
  const [isMissingFieldsOpen, setIsMissingFieldsOpen] = useState(false);
  const { sectionColors } = TableComponents;
  const [mainTabs, setMainTabs] = useState([]);
  const [mainSections, setMainSections] = useState({});
  const [mainSubsections, setMainSubsections] = useState({});

  const [sections, setSections] = useState([]);
  const [processedSections, setProcessedSections] = useState([]);

  const getTableInfo = (fieldName) => {
    // Default table info
    const defaultInfo = {
      table: 'acc_portal_company_duplicate',
      idColumn: 'id',
      useCompanyName: false,
      useId: true
    };

    // Mapping of field prefixes to their respective tables
    const tableMapping = {
      'nssf_': {
        table: 'nssf_companies_duplicate',
        idColumn: 'company_name',
        useCompanyName: true
      },
      'nhif_': {
        table: 'nhif_companies_duplicate2',
        idColumn: 'company_name',
        useCompanyName: true
      },
      'ecitizen_': {
        table: 'ecitizen_companies_duplicate',
        idColumn: 'name',
        useCompanyName: true
      },
      'etims_': {
        table: 'etims_companies_duplicate',
        idColumn: 'company_name',
        useCompanyName: true
      }
    };

    // Check if field belongs to a specific table
    for (const [prefix, info] of Object.entries(tableMapping)) {
      if (fieldName.startsWith(prefix)) {
        return info;
      }
    }

    // Return default if no specific mapping found
    return defaultInfo;
  };

  const getTableMapping = (fieldName) => {
    const mappings = {
      // Company table fields
      company_: {
        table: 'acc_portal_company_duplicate',
        idField: 'company_name',
        matchField: 'company_name'
      },
      // NSSF fields
      nssf_: {
        table: 'nssf_companies_duplicate',
        idField: 'company_name',
        matchField: 'company_name'
      },
      // NHIF fields
      nhif_: {
        table: 'nhif_companies_duplicate2',
        idField: 'company_name',
        matchField: 'company_name'
      },
      // eCitizen fields
      ecitizen_: {
        table: 'ecitizen_companies_duplicate',
        idField: 'name',
        matchField: 'name'
      },
      // etims fields
      etims_: {
        table: 'etims_companies_duplicate',
        idField: 'company_name',
        matchField: 'company_name'
      }
    };

    // Find matching prefix
    const prefix = Object.keys(mappings).find(p => fieldName.startsWith(p));
    return prefix ? mappings[prefix] : mappings.company_;
  };

  const sectionsWithSeparators = [
    { name: 'index', fields: [{ name: 'index', label: '#' }], label: '#' },
    { isSeparator: true },
    { name: 'companyDetails', fields: formFields.companyDetails.fields, label: 'Company Details' },
    { isSeparator: true },
    // Add other sections as needed
  ];

  const allFieldsWithSeparators = sectionsWithSeparators.flatMap(section =>
    section.isSeparator
      ? [{ isSeparator: true }]
      : section.fields
  );

  const fetchSectionsAndFields = async () => {
    try {
      const { data: mappings, error } = await supabase
        .from('profile_category_table_mapping')
        .select('*')
        .order('Tabs', { ascending: true });

      if (error) throw error;

      // Process mappings to get unique sections and their fields
      const processedData = mappings.reduce((acc, mapping) => {
        const sectionsData = typeof mapping.sections_sections === 'string'
          ? JSON.parse(mapping.sections_sections)
          : mapping.sections_sections;

        const columnMappings = typeof mapping.column_mappings === 'string'
          ? JSON.parse(mapping.column_mappings)
          : mapping.column_mappings;

        Object.keys(sectionsData).forEach(section => {
          if (!acc[section]) {
            acc[section] = {
              name: section,
              label: section,
              fields: [],
              categorizedFields: []
            };
          }

          // Process fields from column mappings
          Object.entries(columnMappings).forEach(([key, label]) => {
            const [table, field] = key.split('.');
            acc[section].fields.push({
              name: field,
              label: label,
              table: table
            });
          });
        });

        return acc;
      }, {});

      // Convert to array and add separators
      const sectionsWithSeparators = [
        { name: 'index', fields: [{ name: 'index', label: '#' }], label: '#' },
        { isSeparator: true },
        ...Object.values(processedData).flatMap(section => [
          section,
          { isSeparator: true }
        ])
      ];

      setSections(sectionsWithSeparators);

      // Generate processed sections with reference numbers
      const processed = generateReferenceNumbers([
        { name: 'index', fields: [{ name: 'index', label: '#' }], label: '#' },
        { isSeparator: true },
        ...Object.values(processedData).map(section => ({
          name: section.name,
          label: section.label,
          categorizedFields: section.fields.reduce((acc, field) => {
            const category = field.table;
            const existingCategory = acc.find(cat => cat.category === category);

            if (existingCategory) {
              existingCategory.fields.push(field);
            } else {
              acc.push({
                category,
                fields: [field],
                colSpan: 1
              });
            }

            return acc;
          }, [])
        }))
      ]);

      setProcessedSections(processed);

    } catch (error) {
      console.error('Error fetching sections:', error);
      toast.error('Failed to fetch sections');
    }
  };

  useEffect(() => {
    fetchSectionsAndFields();
    fetchAllData();
    fetchMainStructure();
    // Add event listener for data refresh
    const handleRefresh = () => fetchAllData();
    window.addEventListener('refreshData', handleRefresh);

    return () => {
      window.removeEventListener('refreshData', handleRefresh);
    };
  }, []);

  const fetchAllData = async () => {
    try {
      // Fetch data from all company-related tables concurrently
      const [
        { data: companies, error: companiesError },
        { data: users, error: usersError },
        { data: directors, error: directorsError },
        { data: nssfData, error: nssfError },
        { data: nhifData, error: nhifError },
        { data: passwordCheckers, error: passwordCheckersError },
        { data: ecitizenData, error: ecitizenError },
        { data: etimsData, error: etimsError },
        { data: accPortalDirectors, error: accPortalDirectorsError }
      ] = await Promise.all([
        supabase.from('acc_portal_company_duplicate').select('*').order('id', { ascending: true }),
        supabase.from('acc_portal_clerk_users_duplicate').select('*'),
        supabase.from('acc_portal_directors_duplicate').select('*'),
        supabase.from('nssf_companies_duplicate').select('*'),
        supabase.from('nhif_companies_duplicate2').select('*'),
        supabase.from('PasswordChecker_duplicate').select('*'),
        supabase.from('ecitizen_companies_duplicate').select('*'),
        supabase.from('etims_companies_duplicate').select('*'),
        supabase.from('acc_portal_directors_duplicate').select('*')
      ]);

      // Handle any errors that occurred during the fetch
      if (companiesError || usersError || directorsError || nssfError || nhifError || passwordCheckersError || ecitizenError || etimsError || accPortalDirectorsError) {
        console.error('Error fetching data from one or more tables:', {
          companiesError,
          usersError,
          directorsError,
          nssfError,
          nhifError,
          passwordCheckersError,
          ecitizenError,
          etimsError,
          accPortalDirectorsError
        });
        toast.error('Failed to fetch data from one or more tables');
        return;
      }

      // Group and combine the data
      const groupedData = companies.map(company => {
        const user = users.find(u => u.userid === company.userid);
        const companyDirectors = directors.filter(d => d.company_name === company.company_name);
        const nssfInfo = nssfData.find(n => n.company_name === company.company_name);
        const nhifInfo = nhifData.find(n => n.company_name === company.company_name);
        const passwordCheckerInfo = passwordCheckers.find(p => p.company_name === company.company_name);
        const ecitizenInfo = ecitizenData.find(e => e.name === company.company_name);
        const etimsInfo = etimsData.find(e => e.company_name === company.company_name);
        const accPortalDirectorInfo = accPortalDirectors.filter(d => d.company_id === company.id); // Assuming company_id links to directors

        return {
          company: {
            ...company,
            ...user?.metadata,
            ...nssfInfo,
            ...nhifInfo,
            ...passwordCheckerInfo,
            ...etimsInfo,
            ...ecitizenInfo,
          },
          directors: accPortalDirectorInfo,
          rows: [{
            ...company,
            ...user?.metadata,
            ...nssfInfo,
            ...nhifInfo,
            ...passwordCheckerInfo,
            ...ecitizenInfo,
            ...etimsInfo,
            isFirstRow: true
          }],
          rowSpan: 1
        };
      });

      setData(groupedData);
    } catch (error) {
      console.error('Error fetching data:', error);
      toast.error('An error occurred while fetching data');
    } finally {
      setLoading(false);
    }
  };

  const fetchMainStructure = async () => {
    try {
      const { data: mappings, error } = await supabase
        .from('profile_category_table_mapping')
        .select('*')
        .order('Tabs', { ascending: true });

      if (error) throw error;

      const tabs = [...new Set(mappings.map(m => m.Tabs))];
      const sections = {};
      const subsections = {};
      const fields = {};

      mappings.forEach(mapping => {
        const sectionsData = typeof mapping.sections_sections === 'string'
          ? JSON.parse(mapping.sections_sections)
          : mapping.sections_sections;
        const subsectionsData = typeof mapping.sections_subsections === 'string'
          ? JSON.parse(mapping.sections_subsections)
          : mapping.sections_subsections;
        const columnMappings = typeof mapping.column_mappings === 'string'
          ? JSON.parse(mapping.column_mappings)
          : mapping.column_mappings;

        if (sectionsData) {
          Object.keys(sectionsData).forEach(section => {
            // Process sections
            if (!sections[mapping.Tabs]) {
              sections[mapping.Tabs] = new Set();
            }
            sections[mapping.Tabs].add(section);

            // Process subsections
            if (subsectionsData && subsectionsData[section]) {
              if (!subsections[section]) {
                subsections[section] = new Set();
              }
              const subs = Array.isArray(subsectionsData[section])
                ? subsectionsData[section]
                : [subsectionsData[section]];
              subs.forEach(sub => {
                subsections[section].add(sub);

                // Process fields for each subsection
                if (columnMappings) {
                  if (!fields[sub]) {
                    fields[sub] = [];
                  }
                  Object.entries(columnMappings).forEach(([key, label]) => {
                    fields[sub].push({
                      name: key.split('.')[1],
                      label,
                      table: key.split('.')[0],
                      category: sub
                    });
                  });
                }
              });
            }
          });
        }
      });

      setMainTabs(tabs);
      setMainSections(Object.fromEntries(
        Object.entries(sections).map(([k, v]) => [k, Array.from(v)])
      ));
      setMainSubsections(Object.fromEntries(
        Object.entries(subsections).map(([k, v]) => [k, Array.from(v)])
      ));
      setFormFields(fields);

      return mappings;
    } catch (error) {
      console.error('Error fetching structure:', error);
      toast.error('Failed to fetch structure');
      return [];
    }
  };

  useEffect(() => {
    const fetchFieldsForSection = async (section, subsection) => {
      try {
        const { data, error } = await supabase
          .from('profile_category_table_mapping')
          .select('*')
          .match({
            sections_sections: JSON.stringify({ [section]: true }),
            sections_subsections: JSON.stringify({ [section]: subsection })
          });

        if (error) throw error;

        // Return fields in array format
        return data.reduce((acc, mapping) => {
          const columnMappings = safeJSONParse(mapping.column_mappings);
          const fields = Object.entries(columnMappings).map(([key, label]) => ({
            name: key.split('.')[1],
            label,
            table: key.split('.')[0],
            category: subsection
          }));

          return {
            ...acc,
            [subsection]: fields || [] // Ensure fields is an array
          };
        }, {});

      } catch (error) {
        console.error('Error fetching fields:', error);
        return {};
      }
    };

    const updateFormFields = async () => {
      const fields = {};

      for (const [tab, sections] of Object.entries(mainSections)) {
        for (const section of sections) {
          const subsections = mainSubsections[section] || [];
          for (const subsection of subsections) {
            const sectionFields = await fetchFieldsForSection(section, subsection);
            Object.assign(fields, sectionFields);
          }
        }
      }

      setFormFields(fields);
    };

    updateFormFields();
  }, [mainSections, mainSubsections]);

  if (loading) {
    return <div>Loading...</div>;
  }

  const countMissingFields = (row) => {
    const fields = Object.keys(row).filter(key =>
      key !== 'index' &&
      key !== 'isFirstRow' &&
      key !== 'rowSpan' &&
      !key.startsWith('data.') // Exclude nested data fields
    );

    const totalFields = fields.length;
    const completedFields = fields.filter(field => row[field] !== null && row[field] !== '').length;
    const missingFields = totalFields - completedFields;

    return (
      <div className='flex gap-2 text-sm font-medium border rounded-lg p-2 bg-gray-50'>
        <span className='text-blue-600 border-r pr-2'>T: {totalFields}</span>
        <span className='text-green-600 border-r pr-2'>C: {completedFields}</span>
        <span className='text-red-600'>P: {missingFields}</span>
      </div>
    );
  };

  // Add function to calculate overall missing counts
  const calculateMissingCounts = () => {
    if (!data.length || !data[0].rows.length) return {};

    const fields = Object.keys(data[0].rows[0]).filter(key =>
      key !== 'index' &&
      key !== 'isFirstRow' &&
      key !== 'rowSpan' &&
      !key.startsWith('data.')
    );

    const totalFields = fields.length;
    const allRows = data.flatMap(group => group.rows);

    const completedFields = fields.filter(field =>
      allRows.every(row => row[field] !== null && row[field] !== '')
    ).length;

    const totalMissing = totalFields - completedFields;

    const columnMissing = {};
    fields.forEach(field => {
      columnMissing[field] = allRows.filter(row =>
        row[field] === null || row[field] === ''
      ).length;
    });

    return { totalFields, completedFields, totalMissing, columnMissing };
  };

  const { totalFields, completedFields, totalMissing, columnMissing } = calculateMissingCounts();

  const calculateColumnStatistics = () => {
    if (!data.length) return {};

    const allRows = data.flatMap(group => group.rows);
    const columnStats = {};

    allFieldsWithSeparators.forEach(field => {
      if (!field.isSeparator) {
        const total = allRows.length;
        const completed = allRows.filter(row =>
          row[field.name] !== null &&
          row[field.name] !== '' &&
          row[field.name] !== undefined
        ).length;

        columnStats[field.name] = {
          total,
          completed,
          pending: total - completed
        };
      }
    });

    return columnStats;
  };

  const columnStats = calculateColumnStatistics();

  // Calculate section and column references
  const generateReferences = () => {
    let sectionRef = 1;
    let columnRef = 1;
    const references = {
      sections: {},
      columns: {}
    };

    processedSections.forEach(section => {
      if (!section.isSeparator) {
        references.sections[section.name] = sectionRef++;

        section.categorizedFields?.forEach(category => {
          if (!category.isSeparator) {
            category.fields.forEach(field => {
              references.columns[field.name] = columnRef++;
            });
          }
        });
      }
    });

    return references;
  };

  const references = generateReferences();

  // Add this handler function
  const handleCompanyClick = (company) => {
    setSelectedCompany(company);
    setIsEditDialogOpen(true);
  };

  // Add this handler for after successful edit
  const handleEditSave = (updatedData) => {
    // Update the local data
    const newData = data.map(item => {
      if (item.company.id === updatedData.id) {
        return {
          ...item,
          company: updatedData
        };
      }
      return item;
    });
    setData(newData);
  };

  return (
    <>
      <div className="flex gap-2">
        <SettingsDialog
          mainTabs={mainTabs}
          mainSections={mainSections}
          mainSubsections={mainSubsections}
          onStructureChange={fetchMainStructure}
        />
        <Button
          onClick={() => setIsImportDialogOpen(true)}
          className="flex items-center gap-2"
        >
          <Upload className="h-4 w-4" />
          Import
        </Button>
        <Button
          onClick={() => handleExport(data, processedSections)}
          className="flex items-center gap-2"
        >
          <Download className="h-4 w-4" />
          Export
        </Button>
      </div>

      <Tabs defaultValue={mainTabs[0]} className="w-full space-y-4">
        <TabsList className="grid w-full grid-cols-10 bg-gray-100 rounded-lg p-1">
          {mainTabs.map(tab => (
            <TabsTrigger
              key={tab}
              value={tab}
              className="px-4 py-2 text-sm font-medium hover:bg-white hover:text-primary transition-colors"
            >
              {tab}
            </TabsTrigger>
          ))}
        </TabsList>

        {mainTabs.map(tab => {
          return (
            <TabsContent key={tab} value={tab}>
              <ScrollArea className="w-full h-[calc(100vh-200px)]" type="scroll">
                <div className="min-w-max"> {/* Ensures horizontal scrolling */}
                  <Table
                    data={data}
                    handleCompanyClick={handleCompanyClick}
                    onMissingFieldsClick={(company) => {
                      setSelectedMissingFields({
                        ...company,
                        missingFields: getMissingFields(company)
                      });
                      setIsMissingFieldsOpen(true);
                    }}
                    processedSections={processedSections}
                    tab={tab}
                    sections={mainSections[tab]}
                    subsections={mainSubsections}
                    visibleColumns={getVisibleColumns(allFieldsWithSeparators)}
                  />
                </div>
                <ScrollBar orientation="horizontal" />
              </ScrollArea>
            </TabsContent>
          );
        })}
      </Tabs>

      {/* Dialogs */}
      {isImportDialogOpen && (
        <ImportDialog
          open={isImportDialogOpen}
          onOpenChange={setIsImportDialogOpen}
          onImport={fetchAllData}
          processedSections={processedSections}
        />
      )}

      {isEditDialogOpen && selectedCompany && (
        <CompanyEditDialog
          company={selectedCompany}
          open={isEditDialogOpen}
          onOpenChange={setIsEditDialogOpen}
          onSave={handleEditSave}
        />
      )}

      {isMissingFieldsOpen && selectedMissingFields && (
        <MissingFieldsDialog
          company={selectedMissingFields}
          open={isMissingFieldsOpen}
          onOpenChange={setIsMissingFieldsOpen}
        />
      )}
    </>
  );
};

export default OverallView;
```

### Creating `TableComponents.tsx`

Let's create a new `TableComponents.tsx` file to handle rendering of table components like headers, cells, etc.

#### `app\admin\overallview\components\TableComponents.tsx`
```tsx
app\admin\overallview\components\TableComponents.tsx
```tsx
import React from 'react';
import { TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table";
import { ScrollArea } from '@/components/ui/scroll-area';

export const renderSeparatorCell = (key, type) => {
  return (
    <TableCell key={key} className="bg-gray-200 p-2">
      {type === 'section' ? '--- Section ---' : type === 'category' ? '--- Category ---' : '--- Subcategory ---'}
    </TableCell>
  );
};

export const TableComponents = {
  sectionColors: {
    'Company Details': 'bg-blue-50',
    'NSSF Details': 'bg-green-50',
    'NHIF Details': 'bg-red-50',
    'E-Citizen Details': 'bg-yellow-50',
    'TIMS Details': 'bg-purple-50',
    'NITA Details': 'bg-orange-50',
    'Housing Levy Details': 'bg-cyan-50',
    'Tourism Levy Details': 'bg-pink-50',
    'Standard Levy Details': 'bg-gray-50',
    'Sheria Details': 'bg-teal-50',
    'VAT Details': 'bg-lime-50',
    'Tax Status Details': 'bg-indigo-50',
    'Other Details': 'bg-violet-50'
  }
};
```

### Integrating `TableComponents.tsx` with `Table.tsx`

Ensure that `Table.tsx` uses `TableComponents` for rendering.

#### `app\admin\overallview\components\overview\Table.tsx`
```tsx
app\admin\overallview\components\overview\Table.tsx
```tsx
import React from 'react';
import { TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table";
import { ScrollArea } from '@/components/ui/scroll-area';
import { renderSeparatorCell } from './TableComponents';
import { Column } from '../../functionalities';

interface TableProps {
  data: any[];
  handleCompanyClick: (company: any) => void;
  onMissingFieldsClick: (company: any) => void;
  processedSections: any[];
  tab: string;
  sections: string[];
  subsections: Record<string, string[]>;
  visibleColumns: Column[];
}

export const Table = ({ data, handleCompanyClick, onMissingFieldsClick, processedSections, tab, sections, subsections, visibleColumns }: TableProps) => {
  const filteredData = data.filter(item => sections.includes(item.company.section) && subsections[item.company.section]?.includes(item.company.subsection));

  return (
    <ScrollArea className="w-full h-full">
      <table className="w-full border-collapse">
        <thead>
          <tr className="bg-gray-100">
            {visibleColumns.map(column => (
              <th key={column.id} className="font-medium p-2">
                {column.label}
              </th>
            ))}
          </tr>
        </thead>
        <tbody>
          {filteredData.map((item, index) => (
            <TableRow key={index}>
              {visibleColumns.map(column => {
                if (column.isSeparator) {
                  return renderSeparatorCell(`col-ref-sep-${index}-${column.id}`, 'section');
                }
                return (
                  <TableCell key={column.id} className="p-2">
                    {item.company[column.accessor(item.company)]}
                  </TableCell>
                );
              })}
            </TableRow>
          ))}
        </tbody>
      </table>
    </ScrollArea>
  );
};
```

### Ensuring Dynamic Data Fetching

Ensure that the data fetching logic is correctly implemented in `page.tsx`.

#### `app\admin\overallview\page.tsx`
```tsx
app\admin\overallview\page.tsx
```tsx
import React, { useEffect, useState, useCallback, useRef } from 'react';
import { formFields } from './formfields';
import { supabase } from '@/lib/supabaseClient';
import { ScrollArea, ScrollBar } from '@/components/ui/scroll-area';
import { Tabs, TabsList, TabsTrigger, TabsContent } from "@/components/ui/tabs";
import { Card, CardContent } from "@/components/ui/card";
import { Button } from '@/components/ui/button';
import { Download, Upload } from 'lucide-react';
import { Dialog, DialogContent, DialogHeader, DialogTitle } from '@/components/ui/dialog';
import { toast } from "sonner";
import { useTableFunctionalities, CompanyEditDialog } from './components/functionalities';
import { Search, Filter, X } from 'lucide-react';
import { groupFieldsByCategory, groupDataByCategory, calculateFieldStats, handleExport, handleFileImport, calculateTotalFields, calculatePendingFields, calculateCompletedFields } from './components/utility';
import { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuTrigger } from "@/components/ui/dropdown-menu";
import { SettingsDialog } from './components/overview/Dialogs/settingsDialog';
import { MissingFieldsDialog, getMissingFields } from './components/missingFieldsDialog';
import { ImportDialog } from './components/overview/Dialogs/ImportDialog';
import { Table, TableComponents } from './components/overview/TableComponents';

function generateReferenceNumbers(sections) {
  let sectionCounter = 1;

  return sections.map(section => {
    if (section.isSeparator) return section;

    // Skip numbering for index section
    if (section.name === 'index') return section;

    // Add section number (e.g., "1. Company Details")
    const sectionRef = `${sectionCounter}`;

    // Process categorized fields
    if (section.categorizedFields) {
      let categoryCounter = 1;

      const processedCategories = section.categorizedFields.map(category => {
        if (category.isSeparator) return category;

        // Add category number (e.g., "1.1 General")
        const categoryRef = `${sectionRef}.${categoryCounter}`;
        categoryCounter++;

        let fieldCounter = 1;
        const processedFields = category.fields.map(field => {
          // Add field number (e.g., "1.1.1 Company Name")
          const fieldRef = `${categoryRef}.${fieldCounter}`;
          fieldCounter++;

          return {
            ...field,
            reference: fieldRef
          };
        });

        return {
          ...category,
          reference: categoryRef,
          fields: processedFields
        };
      });

      if (section.name !== 'index') sectionCounter++;
      return {
        ...section,
        reference: sectionRef,
        categorizedFields: processedCategories
      };
    }

    if (section.name !== 'index') sectionCounter++;
    return section;
  });
}

const OverallView = () => {
  const [data, setData] = useState([]);
  const [loading, setLoading] = useState(true);
  const [isImportDialogOpen, setIsImportDialogOpen] = useState(false);
  const {
    filteredData,
    globalFilter,
    handleGlobalSearch,
    columnVisibility,
    toggleColumnVisibility,
    sectionVisibility,
    toggleSectionVisibility,
    categoryVisibility,
    toggleCategoryVisibility,
    getVisibleColumns,
    resetAll
  } = useTableFunctionalities(data);
  const [selectedCompany, setSelectedCompany] = useState(null);
  const [isEditDialogOpen, setIsEditDialogOpen] = useState(false);
  const [selectedMissingFields, setSelectedMissingFields] = useState(null);
  const [isMissingFieldsOpen, setIsMissingFieldsOpen] = useState(false);
  const { sectionColors } = TableComponents;
  const [mainTabs, setMainTabs] = useState([]);
  const [mainSections, setMainSections] = useState({});
  const [mainSubsections, setMainSubsections] = useState

> Tokens: 42k sent, 8.2k received.  
>  
>  
> Model openai/Qwen/Qwen2.5-Coder-32B-Instruct has hit a token limit!  
> Token counts below are approximate.  
>  
> Input tokens: ~40,305 of 0 -- possibly exhausted context window!  
> Output tokens: ~8,159 of 0 -- possibly exceeded output limit!  
> Total tokens: ~48,464 of 0 -- possibly exhausted context window!  
>  
> To reduce output tokens:  
> - Ask for smaller changes in each request.  
> - Break your code into smaller source files.  
>  
> To reduce input tokens:  
> - Use /tokens to see token usage.  
> - Use /drop to remove unneeded files from the chat session.  
> - Use /clear to clear the chat history.  
> - Break your code into smaller source files.  
> https://aider.chat/docs/troubleshooting/token-limits.html  
